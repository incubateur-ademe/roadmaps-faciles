# Plan — Connecteur Notion (two-way sync)

## Modèle Prisma

### TenantIntegration
```
id              Int @id @default(autoincrement())
tenantId        Int (FK → Tenant)
type            IntegrationType (enum: NOTION)
name            String — label libre
config          Json — credentials chiffrées + mapping config
enabled         Boolean @default(true)
lastSyncAt      DateTime?
syncIntervalMinutes Int? — null = manuel uniquement
createdAt/updatedAt
```
Pas de unique(tenantId, type) — N intégrations du même type possibles.

### IntegrationMapping
```
id              Int @id
integrationId   Int (FK → TenantIntegration, onDelete: Cascade)
localType       String — "board" | "post" | "post_status"
localId         Int
remoteId        String — Notion page/database/option ID
remoteUrl       String?
syncStatus      IntegrationSyncStatus (enum: SYNCED, PENDING, ERROR, CONFLICT)
lastSyncAt      DateTime?
lastError       String?
metadata        Json? — { direction: "inbound" | "outbound", ... }
createdAt/updatedAt
unique(integrationId, localType, localId)
```

### IntegrationSyncLog
```
id              Int @id
integrationId   Int (FK → TenantIntegration, onDelete: Cascade)
mappingId       Int? (FK → IntegrationMapping, nullable)
direction       SyncDirection (enum: INBOUND, OUTBOUND)
status          SyncLogStatus (enum: SUCCESS, ERROR, SKIPPED, CONFLICT)
message         String?
details         Json?
createdAt       DateTime @default(now())
```

### AuditAction additions
INTEGRATION_CREATE, INTEGRATION_UPDATE, INTEGRATION_DELETE, INTEGRATION_SYNC

## Post sync representation

Option retenue : **IntegrationMapping seul** (pas de modification du modèle Post).
- Posts inbound = vrais Posts créés en DB, liés par IntegrationMapping
- Posts outbound = Posts existants avec mapping vers Notion page
- Multi-intégration par post supporté
- Query "is synced?" via JOIN/EXISTS sur IntegrationMapping

## Config JSON (TenantIntegration.config)

```jsonc
{
  "apiKey": "ntn_encrypted...",
  "databaseId": "notion-db-uuid",
  "databaseName": "Product Roadmap",
  "propertyMapping": {
    "title": "Name",
    "description": { "type": "property", "name": "Description" } // ou { "type": "page_content" }
    "status": "Status",
    "board": "Category",
    "tags": "Tags",
    "commentsInfo": "RF Comments",
    "likes": "Votes"
  },
  "statusMapping": {
    "<notion-option-id>": { "localId": 42, "notionName": "In Progress" }
  },
  "boardMapping": {
    "<notion-option-id>": { "localId": 10, "notionName": "Feature Requests" }
  },
  "syncDirection": "bidirectional", // | "inbound" | "outbound"
  "lastSyncCursor": "2025-01-15T10:00:00.000Z"
}
```

## Provider Layer

```
src/lib/integration-provider/
├── IIntegrationProvider.ts
├── types.ts
├── encryption.ts          — AES-256-GCM, env var INTEGRATION_ENCRYPTION_KEY
├── index.ts               — Factory: createIntegrationProvider(type, config)
└── impl/
    └── NotionIntegrationProvider.ts — @notionhq/client
```

Interface IIntegrationProvider:
- testConnection(): Promise<ConnectionTestResult>
- listRemoteDatabases(): Promise<Array<RemoteDatabase>>
- getRemoteDatabaseSchema(databaseId): Promise<RemoteDatabaseSchema>
- syncOutbound(post, board, status): Promise<SyncResult>
- syncInbound(since: Date): Promise<Array<InboundChange>>
- buildRemoteUrl(remoteId): string
- updateCommentsField(remoteId, count, tenantUrl): Promise<void>
- updateLikesField(remoteId, count): Promise<void>

Instancié à la demande avec config JSON déchiffré. PAS un singleton global.

## Cron Manager

```
src/lib/cron-manager/
├── ICronManager.ts
├── index.ts               — Factory: getCronManager()
└── impl/
    ├── NoopCronManager.ts
    └── RouteCronManager.ts
```

Interface ICronManager:
- registerJob(integration): Promise<void>
- unregisterJob(integrationId): Promise<void>
- processDueJobs(): Promise<CronExecutionReport>

RouteCronManager: schedule en DB (syncIntervalMinutes), route /api/cron/integrations protégée par X-Cron-Secret.
Config: config.integrations.cronManager ("noop" | "route") + config.integrations.cronSecret

## Repo Layer

```
src/lib/repo/
├── IIntegrationRepo.ts
├── IIntegrationMappingRepo.ts
├── IIntegrationSyncLogRepo.ts
└── impl/
    ├── IntegrationRepoPrisma.ts
    ├── IntegrationMappingRepoPrisma.ts
    └── IntegrationSyncLogRepoPrisma.ts
```

## Use Cases

```
src/useCases/integrations/
├── CreateIntegration.ts
├── UpdateIntegration.ts
├── DeleteIntegration.ts           — avec option cleanup posts inbound
├── TestIntegrationConnection.ts
├── ListIntegrationsForTenant.ts
├── GetNotionDatabases.ts
├── GetNotionDatabaseSchema.ts
├── ConfigureIntegrationMapping.ts — sauvegarde le mapping complet
├── SyncIntegration.ts             — orchestre inbound + outbound
├── ResolveSyncConflict.ts         — admin + modos
└── GetIntegrationSyncLogs.ts
```

## Admin UI

```
src/app/[domain]/(domain)/(authenticated)/admin/integrations/
├── page.tsx                       — Liste des intégrations
├── IntegrationsList.tsx
├── actions.ts
├── new/
│   ├── page.tsx                   — Wizard avec Stepper DSFR
│   └── NotionWizard.tsx           — Zustand + Immer store
│   └── useNotionWizardStore.ts
│   └── steps/
│       ├── ConnectionStep.tsx
│       ├── DatabaseStep.tsx
│       ├── MappingStep.tsx
│       └── ConfigStep.tsx
├── [integrationId]/
│   ├── page.tsx
│   ├── IntegrationDetail.tsx
│   ├── SyncLogTable.tsx
│   ├── ConflictResolver.tsx
│   └── actions.ts
```

Stepper DSFR: currentStep, stepCount, title, nextTitle — composant de progression.
Wizard state: Zustand store + immer middleware. Pas de XState.

## Sync Flow

### Outbound (RF → Notion)
1. Pour chaque post dans boards mappés, depuis lastSyncAt
2. Mapping existe ? → pages.update() / sinon pages.create() + IntegrationMapping
3. Update champs comments (count + lien) et likes (count)
4. Log dans IntegrationSyncLog

### Inbound (Notion → RF)
1. Query dataSources.query avec last_edited_time > lastSyncCursor
2. Mapping existe ? → update Post / sinon create Post (APPROVED, pas de modération)
3. Status/Board non mappé → log ERROR, skip
4. Update lastSyncCursor

### Conflits (two-way)
- Compare post.updatedAt vs page.last_edited_time vs mapping.lastSyncAt
- Les deux modifiés depuis dernier sync → CONFLICT + log
- Admin + modos résolvent dans l'UI (choisir RF ou Notion)

### Description = contenu de page
- Option "page_content" dans propertyMapping.description
- Inbound: blocks.children.list → Markdown
- Outbound: Markdown → blocs Notion (paragraphes, headings, listes, code)
- Blocs non supportés ignorés + log

## Posts inbound = readonly
- Pas de modération (directement APPROVED)
- Édition/suppression bloquée (badge "Synced depuis Notion")
- Votes + commentaires restent actifs

## "Voir sur Notion"
- Modérateurs+ uniquement (role check serveur)
- Badge/lien sur page détail post si IntegrationMapping existe
- remoteUrl construit par provider

## Débranchement
1. Désactiver (enabled=false) — réversible, données préservées
2. Supprimer — Cascade delete mappings+logs, posts RF restent, pages Notion restent
3. Supprimer + cleanup — option "supprimer X posts importés" (inbound seulement, via metadata.direction)

## Likes
- Champ Notion mappé: number (count brut) ou rich_text ("12 votes")
- Outbound only — RF fait autorité
- propertyMapping.likes dans config JSON

## Commentaires
- Champ Notion rich_text/text avec count + lien
- Format: "5 commentaires — Voir sur {tenantUrl}/board/{slug}/post/{postId}"
- Outbound only

## Ordre d'implémentation — Statut

1. ~~Schema Prisma + prisma db push~~ ✅
2. ~~Encryption util (AES-256-GCM)~~ ✅
3. ~~Provider interface + Notion impl + @notionhq/client~~ ✅
   - Notion SDK v5.9.0 : `dataSources.query()` (pas `databases.query()`), `isFullDataSource`, search filter `"data_source"`
4. ~~Cron manager (ICronManager + RouteCronManager)~~ ✅ (NoopCronManager + route handler POST /api/cron/integrations)
5. ~~Repo layer (3 repos)~~ ✅
6. ~~Use cases~~ ✅ (Create, Update, Delete, List, Sync, ResolveSyncConflict, GetSyncLogs, TestConnection)
7. ~~Admin UI — liste + wizard + détail/logs~~ ✅
8. ~~"Voir sur Notion" sur page post (modos+)~~ ✅
9. ~~Débranchement (disable/delete flows)~~ ✅
10. ~~Traductions fr + en~~ ✅
11. ~~Tests~~ ✅ (partiel — testu + testi)

### Tests implémentés

| Couche | Fichiers | Tests |
|--------|----------|-------|
| testu | `encryption.test.ts` | 7 (roundtrip, format, unicité, erreurs, unicode) |
| testi | `CreateIntegration.test.ts` | 2 (happy path + connection failure) |
| testi | `DeleteIntegration.test.ts` | 5 (sans cleanup, avec cleanup, not found, tenant mismatch, empty cleanup) |
| testi | `SyncIntegration.test.ts` | 16 (outbound: sync/re-sync/skip inbound/error/exception/empty; inbound: create/update/default board/no board/exception; bidi conflict; lastSyncAt update) |
| testi | `ResolveSyncConflict.test.ts` | 8 (local push/remote pull, not found, tenant mismatch, post not found, push fail, remote not found) |
| testi | `UpdateIntegration.test.ts` | 8 (name, enabled, interval, config merge, re-encrypt, skip re-encrypt, not found, tenant mismatch) |
| testi | `GetIntegrationSyncLogs.test.ts` | 5 (not found, tenant mismatch, default limit, custom limit, empty) |
| testi | `ListIntegrationsForTenant.test.ts` | 2 (list, empty) |
| **Total** | **8 fichiers** | **53 tests** |

### CI

- `.github/filters.yml` : ajout `src/lib/integration-provider/**` dans `test-unit`

### Reste à faire

- [ ] Tests E2E : admin pages, inbound readonly guard, badge Notion, cron 401
- [ ] Tests DB : repos Prisma (IntegrationRepoPrisma, IntegrationMappingRepoPrisma, IntegrationSyncLogRepoPrisma)
- [ ] Wizard : step de sélection de la database Notion (listRemoteDatabases + getRemoteDatabaseSchema) — UI existante, mais dépend d'une vraie API Notion
- [ ] Sync bidirectionnel : UI de résolution de conflits dans la page détail (ConflictResolver.tsx)
- [ ] Cron manager : implémentation réelle (RouteCronManager.processDueJobs)
- [ ] Audit actions : INTEGRATION_SYNC dans la cron route

## Deps npm
- @notionhq/client

## Hors scope
- Polling automatique Notion webhooks (receiver endpoint)
- Webhook sortant sync_failed (garder en tête)
- Trello / projets.numerique.gouv.fr
- OAuth Notion (API key uniquement)

## Notes techniques découvertes

- **Notion SDK v5.9.0** : API cassante vs docs en ligne. `databases.query()` n'existe plus → `dataSources.query()`. `DatabaseObjectResponse` n'a pas de `.properties` → `DataSourceObjectResponse`. Search filter accepte `"data_source"` (pas `"database"`).
- **Prisma 7 enums** : PascalCase (`IntegrationType`, `SyncDirection`) et non SCREAMING_SNAKE (`INTEGRATION_TYPE`, `SYNC_DIRECTION`).
- **`Record<string, unknown>` vs `Prisma.InputJsonValue`** : les champs JSON Prisma requièrent un cast explicite `as unknown as Prisma.InputJsonValue`.
- **Inbound readonly** : double guard nécessaire — UI (canEdit/canDelete=false dans PostPageHOP) + server (action reject avec erreur i18n).
